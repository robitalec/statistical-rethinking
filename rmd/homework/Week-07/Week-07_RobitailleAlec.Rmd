---
author: "Alec L. Robitaille"
output: github_document
editor_options: 
  chunk_output_type: console
---

# Homework: Week 7
2021-09-07 [updated: `r Sys.Date()`]

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rethinking)
options(digits = 2, scipen = 999)
```

### Setup

```{r}
# Packages
library(ggdag)
library(dagitty)
library(data.table)
library(ggplot2)
library(rethinking)
library(cmdstanr)
library(posterior)
library(bayesplot)
library(boot)

# Functions
dag_plot <- function(dag) {
	stat <- node_status(dag, FALSE)
	stat$data$status[is.na(stat$data$status)] <- 'intermediate'
	ggplot(stat, aes(x = x, y = y, xend = xend, yend = yend)) +
	  geom_dag_point(aes(color = status), alpha = 0.5, size = 15) +
	  geom_dag_edges() +
		labs(color = '') + 
	  geom_dag_text(color = 'black') +
		scale_color_manual(values = list('exposure' = '#35608DFF',
																		 'outcome' = '#22A884FF',
																		 'intermediate' = 'grey50')) + 
	  theme_void()
}

cmd_draws <- function(model) {
	as_draws_df(model$draws())
}
```

### Data

```{r}
data(Trolley)
DT <- data.table(Trolley)
precis(DT)
```

Response: 1-7 integer, "how morally permissible the action to be taken (or not) is". Categorical, ordered, but distances between categories is not metric or known. 

Logit = log-odds, cumulative logit = log-cumulative-odds. Both constrained between 0-1. 

Log-cumulative-odds for response 7 will be infinity since log(1/(1-1)) = infinity. 
Given this, we only need K-1 = 6 intercepts. 


### Model: ordered categorical outcome

Probability of data: $R_{i} \sim \text{Ordered-logit}(\phi_{i}, K)$

Linear model: $\phi_{i} = 0$

Prior for each intercept: $K_{k} \sim \text{Normal}(0, 1.5)$


```{r}
register_knitr_engine(override = FALSE)
```

```{cmdstan, output.var = 'model1', cache = TRUE}
data {
  int N;
  int K;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
}
model {
  vector[N] phi;

	for (i in 1:N) {
		phi[i] = beta_action * action[i] + beta_contact * contact[i] + beta_intention * intention[i];
		response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 0.5);
  beta_contact ~ normal(0, 0.5);
  beta_intention ~ normal(0, 0.5);
}
```

```{r, cache = TRUE}
# model1_stan <- 'model1.stan'
# writeLines(readLines(model1_stan))
# model1 <- cmdstan_model(model1_stan, cpp_options = list(stan_threads = TRUE))

model_data <- c(
	as.list(DT[, .(response, action, intention, contact)]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1]
)

model1_sample <-
	model1$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model1_draws <- cmd_draws(model1_sample)

mcmc_areas(model1_draws, regex_pars = 'beta')
```


```{cmdstan, output.var = 'model1_interactions', cache = TRUE}
data {
  int N;
  int K;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
  real beta_intention_contact;
  real beta_intention_action;
}
model {
  vector[N] phi;

	for (i in 1:N) {
		phi[i] = beta_action * action[i] + beta_contact * contact[i] + beta_intention * intention[i] + beta_intention_contact * intention[i] * contact[i]  + beta_intention_action * intention[i] * action[i]
		;
		response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 0.5);
  beta_contact ~ normal(0, 0.5);
  beta_intention ~ normal(0, 0.5);
}
```

```{r, cache = TRUE}
# model1_interactions_stan <- 'model1_interactions.stan'
# writeLines(readLines(model1_interactions_stan))
# model1_interactions <- cmdstan_model(model1_interactions_stan, cpp_options = list(stan_threads = TRUE))

model_data <- c(
	as.list(DT[, .(response, action, intention, contact)]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1]
)

model1_interactions_sample <-
	model1_interactions$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model1_interactions_draws <- cmd_draws(model1_interactions_sample)

mcmc_areas(model1_interactions_draws, regex_pars = 'beta')
mcmc_areas(model1_interactions_draws, regex_pars = 'cut', transformations = inv.logit) + xlim(0, 1)
```


### Model: ordered categorical predictors

Probability of data: $R_{i} \sim \text{Ordered-logit}(\phi_{i}, K)$

Linear model: $\phi_{i} = \beta_{E} \sum_{j=0}^{E_{i}-1}\delta_{j} + \beta{A_{i}}A_{i} + \beta{I_{i}}I_{i} + \beta{C_{i}}C_{i}$

Prior for each intercept: $K_{k} \sim \text{Normal}(0, 1.5)$
Prior for each $\beta$: $\beta_{A}, \beta_{I}, \beta_{C}, \beta_{E}K_{k} \sim \text{Normal}(0, 1)$
Prior for the $\delta$ vector: $\delta \sim \text{Dirichlet}(\alpha)$

Dirichlet distribution = multivariate extension of the beta distribution. Probabilities between zero and one, that all sum to one. It is parameterized by
pseudo-counts of observations. 

The intercept takes the first category, so we add 0 to the sequence of

Make sure to reorder education levels 

```{cmdstan, output.var = 'model2', cache = TRUE}
data {
  int N;
  int K;
  int N_edu;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
  int education[N];
  vector[N_edu - 1] alpha;
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
  real beta_education;

  // Vector N reals that sum to 1
  simplex[7] delta;
}
model {
  vector[N] phi;
  vector[N_edu] delta_j;

  delta ~ dirichlet(alpha);
  delta_j = append_row(0, delta);

	for (i in 1:N) {
    // add beta education  * sum delta j, up to current i's education
    phi[i] = beta_education * sum(delta_j[1:education[i]]) +
      beta_action * action[i] +
      beta_contact * contact[i] +
      beta_intention * intention[i];
    response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 1);
  beta_contact ~ normal(0, 1);
  beta_intention ~ normal(0, 1);
  beta_education ~ normal(0, 1);
}
```


```{r, cache = TRUE}
# model2_stan <- 'model2.stan'
# writeLines(readLines(model2_stan))
# model2 <- cmdstan_model(model2_stan, cpp_options = list(stan_threads = TRUE))

edu_levels <- c(6, 1, 8, 4, 7, 2, 5, 3)
DT[, education := as.integer(edu_levels[edu])]

model_data <- c(
	as.list(DT[, .(response, action, intention, contact, education)]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1],
	N_edu = DT[, uniqueN(education)],
	alpha = list(rep(2, 7))
)


model2_sample <-model2$sample(
	data = model_data,
	chains = 4,
	parallel_chains = 4,
	threads_per_chain = 4
)

model2_draws <- cmd_draws(model2_sample)

mcmc_areas(model2_draws, regex_pars = 'beta')
mcmc_areas(model2_draws, regex_pars = 'delta')
mcmc_areas(model2_draws, regex_pars = 'cut', transformations = inv.logit) + xlim(0, 1)
```


## Question 1

> In the Trolley data—data(Trolley)—we saw how education level (modeled as an
ordered category) is associated with responses. Is this association causal? One
plausible confound is that education is also associated with age, through a
causal process: People are older when they finish school than when they begin
it. Reconsider the Trolley data in this light. Draw a DAG that represents
hypothetical causal relationships among response, education, and age. 


```{r}
dag <- dagify(
  response ~ education + age + action + intention + contact,
  education ~ age,
  contact ~ action,
  exposure = 'education',
  outcome = 'response'
)

dag_plot(dag)
adjustmentSets(dag, exposure = 'education', outcome = 'response', effect = 'total' )
```


Which statistical model or models do you need to evaluate the causal influence of
education on responses? Fit these models to the trolley data. What do you
conclude about the causal relationships among these three variables?


```{cmdstan, output.var = 'model2_age', cache = TRUE}
data {
  int N;
  int K;
  int N_edu;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
  int education[N];
  real age[N];
  vector[N_edu - 1] alpha;
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
  real beta_education;
  real beta_age;

  // Vector N reals that sum to 1
  simplex[7] delta;
}
model {
  vector[N] phi;
  vector[N_edu] delta_j;

  delta ~ dirichlet(alpha);
  delta_j = append_row(0, delta);

	for (i in 1:N) {
    // add beta education  * sum delta j, up to current i's education
    phi[i] = beta_education * sum(delta_j[1:education[i]]) +
      beta_action * action[i] +
      beta_contact * contact[i] +
      beta_age * age[i] +
      beta_intention * intention[i];
    response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 1);
  beta_contact ~ normal(0, 1);
  beta_intention ~ normal(0, 1);
  beta_education ~ normal(0, 1);
  beta_age ~ normal(0, 1);
}

```


```{r, cache = TRUE}
# model2_age_stan <- 'model2_age.stan'
# writeLines(readLines(model2_age_stan))
# model2_age <- cmdstan_model(model2_age_stan, cpp_options = list(stan_threads = TRUE))

edu_levels <- c(6, 1, 8, 4, 7, 2, 5, 3)
DT[, education := as.integer(edu_levels[edu])]

model_data <- c(
	as.list(DT[, .(response, action, intention, contact, education, age = as.numeric(scale(age)))]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1],
	N_edu = DT[, uniqueN(education)],
	alpha = list(rep(2, 7))
)


model2_sample <- model2_age$sample(
	data = model_data,
	chains = 4,
	parallel_chains = 4,
	threads_per_chain = 4
)

model2_draws <- cmd_draws(model2_sample)

mcmc_areas(model2_draws, regex_pars = 'beta')
mcmc_areas(model2_draws, regex_pars = 'delta')
mcmc_areas(model2_draws, regex_pars = 'cut', transformations = inv.logit) + xlim(0, 1)
```



## Question 2

> Consider one more variable in the Trolley data: Gender. Suppose that gender
might influence education as well as response directly. Draw the DAG now that
includes response, education, age, and gender. Using only the DAG, is it
possible that the inferences from Problem 1 are con founded by gender? If so,
define any additional models you need to infer the causal influence of education
on response. What do you conclude?

```{r}
dag <- dagify(
  response ~ education + age + gender + action + intention + contact,
  education ~ age,
  education ~ gender,
  contact ~ action,
  exposure = 'education',
  outcome = 'response'
)

dag_plot(dag)
adjustmentSets(dag, exposure = 'education', outcome = 'response', effect = 'total' )
```



```{cmdstan model2gender, output.var = 'model2_gender', cache = TRUE}
data {
  int N;
  int K;
  int N_edu;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
  int education[N];
  real age[N];
  int gender[N];
  vector[N_edu - 1] alpha;
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
  real beta_education;
  real beta_age;
  real beta_gender;

  // Vector N reals that sum to 1
  simplex[7] delta;
}
model {
  vector[N] phi;
  vector[N_edu] delta_j;

  delta ~ dirichlet(alpha);
  delta_j = append_row(0, delta);

	for (i in 1:N) {
    // add beta education  * sum delta j, up to current i's education
    phi[i] = beta_education * sum(delta_j[1:education[i]]) +
      beta_action * action[i] +
      beta_contact * contact[i] +
      beta_age * age[i] +
      beta_gender * gender[i] +
      beta_intention * intention[i];
    response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 1);
  beta_contact ~ normal(0, 1);
  beta_intention ~ normal(0, 1);
  beta_education ~ normal(0, 1);
  beta_age ~ normal(0, 1);
  beta_gender ~ normal(0, 1);
}
```


```{r, cache = TRUE}
# model2_gender_stan <- 'model2_gender.stan'
# writeLines(readLines(model2_gender_stan))
# model2_gender <- cmdstan_model(model2_gender_stan, cpp_options = list(stan_threads = TRUE))

edu_levels <- c(6, 1, 8, 4, 7, 2, 5, 3)
DT[, education := as.integer(edu_levels[edu])]
model_data <- c(
	as.list(DT[, .(response, action, intention, contact, education, age = as.numeric(scale(age)), gender = ifelse(male == 1, 0, 1))]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1],
	N_edu = DT[, uniqueN(education)],
	alpha = list(rep(2, 7))
)


model2_gender_sample <- model2_gender$sample(
	data = model_data,
	chains = 4,
	parallel_chains = 4,
	threads_per_chain = 4
)

model2_gender_draws <- cmd_draws(model2_gender_sample)

mcmc_areas(model2_gender_draws, regex_pars = 'beta')
mcmc_areas(model2_gender_draws, regex_pars = 'delta')
mcmc_areas(model2_gender_draws, regex_pars = 'cut', transformations = inv.logit) + xlim(0, 1)
```
