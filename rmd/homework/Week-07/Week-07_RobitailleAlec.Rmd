---
author: "Alec L. Robitaille"
output: github_document
editor_options: 
  chunk_output_type: console
---

# Homework: Week 7
2021-09-07 [updated: `r Sys.Date()`]

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rethinking)
options(digits = 2, scipen = 999)
```

### Setup

```{r}
# Packages
library(ggdag)
library(dagitty)
library(data.table)
library(ggplot2)
library(rethinking)
library(cmdstanr)
library(posterior)
library(bayesplot)
library(boot)

# Functions
dag_plot <- function(dag) {
	stat <- node_status(dag, FALSE)
	stat$data$status[is.na(stat$data$status)] <- 'intermediate'
	ggplot(stat, aes(x = x, y = y, xend = xend, yend = yend)) +
	  geom_dag_point(aes(color = status), alpha = 0.5, size = 15) +
	  geom_dag_edges() +
		labs(color = '') + 
	  geom_dag_text(color = 'black') +
		scale_color_manual(values = list('exposure' = '#35608DFF',
																		 'outcome' = '#22A884FF',
																		 'intermediate' = 'grey50')) + 
	  theme_void()
}

cmd_draws <- function(model) {
	as_draws_df(model$draws())
}
```

### Data

```{r}
data(Trolley)
DT <- data.table(Trolley)
precis(DT)
```

Response: 1-7 integer, "how morally permissible the action to be taken (or not) is". Categorical, ordered, but distances between categories is not metric or known. 

Logit = log-odds, cumulative logit = log-cumulative-odds. Both constrained between 0-1. 

Log-cumulative-odds for response 7 will be infinity since log(1/(1-1)) = infinity. 
Given this, we only need K-1 = 6 intercepts. 


### Model: ordered categorical outcome

Probability of data: $R_{i} \sim \text{Ordered-logit}(\phi_{i}, K)$

Linear model: $\phi_{i} = 0$

Prior for each intercept: $K_{k} \sim \text{Normal}(0, 1.5)$


```{r}
register_knitr_engine(override = FALSE)
```

```{cmdstanr, output.var = 'model1'}
data {
  int N;
  int K;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
}
model {
  vector[N] phi;

	for (i in 1:N) {
		phi[i] = beta_action * action[i] + beta_contact * contact[i] + beta_intention * intention[i];
		response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 0.5);
  beta_contact ~ normal(0, 0.5);
  beta_intention ~ normal(0, 0.5);
}
```

```{r}
# model1_stan <- 'model1.stan'
# writeLines(readLines(model1_stan))
# model1 <- cmdstan_model(model1_stan, cpp_options = list(stan_threads = TRUE))

model_data <- c(
	as.list(DT[, .(response, action, intention, contact)]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1]
)

model1_sample <-
	model1$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model1_draws <- cmd_draws(model1_sample)

mcmc_areas(model1_draws, regex_pars = 'beta')
```


```{cmdstanr, output.var = 'model1_interactions'}
data {
  int N;
  int K;
  int response[N];
  int action[N];
  int intention[N];
  int contact[N];
}
parameters {
	// Cut points are the positions of responses along cumulative odds
  ordered[K] cutpoints;
  real beta_action;
  real beta_intention;
  real beta_contact;
  real beta_intention_contact;
  real beta_intention_action;
}
model {
  vector[N] phi;

	for (i in 1:N) {
		phi[i] = beta_action * action[i] + beta_contact * contact[i] + beta_intention * intention[i] + beta_intention_contact * intention[i] * contact[i]  + beta_intention_action * intention[i] * action[i]
		;
		response[i] ~ ordered_logistic(phi[i], cutpoints);
	}

  cutpoints ~ normal(0, 1.5);
  beta_action ~ normal(0, 0.5);
  beta_contact ~ normal(0, 0.5);
  beta_intention ~ normal(0, 0.5);
}
```

```{r}
# model1_interactions_stan <- 'model1_interactions.stan'
# writeLines(readLines(model1_interactions_stan))
# model1_interactions <- cmdstan_model(model1_interactions_stan, cpp_options = list(stan_threads = TRUE))

model_data <- c(
	as.list(DT[, .(response, action, intention, contact)]), 
	N = DT[, .N],
	K = DT[, uniqueN(response) - 1]
)

model1_interactions_sample <-
	model1_interactions$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model1_interactions_draws <- cmd_draws(model1_interactions_sample)

mcmc_areas(model1_interactions_draws, regex_pars = 'beta')
mcmc_areas(model1_interactions_draws, regex_pars = 'cut', transformations = inv.logit) + xlim(0, 1)
```


### Model: ordered categorical predictors
