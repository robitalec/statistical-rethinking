---
author: "Alec L. Robitaille"
output: github_document
editor_options: 
  chunk_output_type: console
---

# Homework: Week 9
2021-09-14 [updated: `r Sys.Date()`]

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Question 1

> Revisit the Bangladesh fertility data, data(bangladesh). Fit a model with both
varying intercepts by district_id and varying slopes of urban (as a 0/1
indicator variable) by district_id. You are still predicting use.contraception.
Inspect the correlation between the intercepts and slopes. Can you interpret
this correlation, in terms of what it tells you about the pattern of
contraceptive use in the sample? It might help to plot the varying effect
estimates for both the intercepts and slopes, by district. Then you can
visualize the correlation and maybe more easily think through what it means to
have a particular correlation. Plotting predicted proportion of women using
contraception, in each district, with urban women on one axis and rural on the
other, might also help.

```{r}
data(bangladesh)
DT <- data.table(bangladesh)
precis(DT)

DT[, id := as.integer(woman)]
DT[, district := as.integer(as.factor(district))]
DT[, contraception := use.contraception]

model_data <- c(as.list(DT[, .(contraception, district, urban)]), 
								N = DT[, .N], N_district = DT[, uniqueN(district)])
```


```{r}
register_knitr_engine(override = FALSE)
```

```{cmdstan, output.var = 'model_q1', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // District, contraception and urban, expecting integers of length N
	int district[N];
	int contraception[N];
	int urban[N];
}
parameters {
	// Alpha and beta urban vectors matching length of number of districts
	vector[N_district] alpha;

	// Beta urban vector matching length of number of districts
	vector[N_district] beta;

	// Hyper parameter alpha bar, beta bar
	real alpha_bar;
	real beta_bar;

	// Correlation matrix, sigma
	// 2 represents the number of predictors
	corr_matrix[2] Rho;
	vector<lower=0>[2] sigma;
}
model {
	// p vector matching length of number of districts
  vector[N] p;

  // Hyper priors: alpha bar, beta urban bar, sigma and Rho
	alpha_bar ~ normal(0, 1);
	beta_bar ~ normal(0, 0.5);
	sigma ~ exponential(1);
	Rho ~ lkj_corr(2);

	// Multivariate normal
  {
	  vector[2] YY[N_district];
	  vector[2] MU;
	  MU = [alpha_bar, beta_bar]';
	  for (j in 1:N_district) {
	  	YY[j] = [alpha[j], beta[j]]';
	  }
	  YY ~ multi_normal(MU, quad_form_diag(Rho, sigma));
  }

	// For each for in data, alpha and beta for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]] + beta[district[i]] * urban[i]);
  }

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}
```

<!-- https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-hierarchical-priors-section.html#optimization-through-vectorization -->


```{r, cache = TRUE}
# model_q1_stan <- 'model_q1.stan'
# writeLines(readLines(model_q1_stan))
# model_q1 <- cmdstan_model(model_q1_stan, cpp_options = list(stan_threads = TRUE))

model_q1_sample <-
	model_q1$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model_q1_draws <- cmd_draws(model_q1_sample)
setDT(model_q1_draws)
mcmc_areas(model_q1_draws, regex_pars = 'alpha')
mcmc_areas(model_q1_draws, regex_pars = 'beta')
mcmc_areas(model_q1_draws, regex_pars = 'bar')
mcmc_areas(model_q1_draws, regex_pars = 'Rho')

precis(model_q1_draws[, .SD, .SDcols = patterns('*bar')])
precis(model_q1_draws[, .SD, .SDcols = patterns('Rho|sigma')], depth = 3)

mcmc_hex(model_q1_draws, regex_pars = '*bar')
```



## Question 2

> Now consider the predictor variables age.centered and living.children, also
contained in data(bangladesh). Suppose that age influences contraceptive use
(changing attitudes) and number of children (older people have had more time to
have kids). Number of children may also directly influence contraceptive use.
Draw a DAG that reflects these hypothetical relationships. Then build models
needed to evaluate the DAG. You will need at least two models. Retain district
and urban, as in Problem 1. What do you conclude about the causal influence of
age and children?

```{r}
dag <- dagify(
  contraceptive_use ~ age + number_children,
  number_children ~ age,
  exposure = 'age',
  outcome = 'contraceptive_use'
)

dag_plot(dag)
adjustmentSets(dag, exposure = 'age', outcome = 'contraceptive_use', effect = 'total')
adjustmentSets(dag, exposure = 'age', outcome = 'contraceptive_use', effect = 'direct')
```


```{r}
DT[, scale_age := as.numeric(scale(age.centered))]
model_data <- c(as.list(DT[, .(contraception, district, urban, scale_age, 
															 n_children = living.children)]), 
								N = DT[, .N], N_district = DT[, uniqueN(district)])
```


```{cmdstan, output.var = 'model_q2_a', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // District, contraception and urban, expecting integers of length N
	int district[N];
	int contraception[N];
	int urban[N];

	// Also scale_age
	real scale_age[N];
}
parameters {
	// Alpha and beta urban vectors matching length of number of districts
	vector[N_district] alpha;

	// Beta urban vector matching length of number of districts
	vector[N_district] beta;

	// Hyper parameter alpha bar, beta bar
	real alpha_bar;
	real beta_bar;

	// scale_age
	real beta_scale_age;

	// Correlation matrix, sigma
	// 2 represents the number of predictors
	corr_matrix[2] Rho;
	vector<lower=0>[2] sigma;
}
model {
	// p vector matching length of number of districts
  vector[N] p;

  // Hyper priors: alpha bar, beta urban bar, sigma and Rho
	alpha_bar ~ normal(0, 1);
	beta_bar ~ normal(0, 0.5);
	sigma ~ exponential(1);
	Rho ~ lkj_corr(2);

	// Multivariate normal
  {
	  vector[2] YY[N_district];
	  vector[2] MU;
	  MU = [alpha_bar, beta_bar]';
	  for (j in 1:N_district) {
	  	YY[j] = [alpha[j], beta[j]]';
	  }
	  YY ~ multi_normal(MU, quad_form_diag(Rho, sigma));
  }

  // Beta scale_age prior
	beta_scale_age ~ normal(0, 1.5);

	// For each for in data, alpha and beta for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]] + beta[district[i]] * urban[i] + beta_scale_age * scale_age[i]);
  }

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}


```

```{r, cache = TRUE}
# model_q2_a_stan <- 'model_q2_a.stan'
# writeLines(readLines(model_q2_a_stan))
# model_q2_a <- cmdstan_model(model_q2_a_stan, cpp_options = list(stan_threads = TRUE))

model_q2_a_sample <-
	model_q2_a$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model_q2_a_draws <- cmd_draws(model_q2_a_sample)
setDT(model_q2_a_draws)
```

```{cmdstan, output.var = 'model_q2_b', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // District, contraception and urban, expecting integers of length N
	int district[N];
	int contraception[N];
	int urban[N];

	// Also scale_age and n_children
	real scale_age[N];
	int n_children[N];
}
parameters {
	// Alpha and beta urban vectors matching length of number of districts
	vector[N_district] alpha;

	// Beta urban vector matching length of number of districts
	vector[N_district] beta;

	// Hyper parameter alpha bar, beta bar
	real alpha_bar;
	real beta_bar;

	// scale_age and n_children
	real beta_scale_age;
	real beta_children;

	// Correlation matrix, sigma
	// 2 represents the number of predictors
	corr_matrix[2] Rho;
	vector<lower=0>[2] sigma;
}
model {
	// p vector matching length of number of districts
  vector[N] p;

  // Hyper priors: alpha bar, beta urban bar, sigma and Rho
	alpha_bar ~ normal(0, 1);
	beta_bar ~ normal(0, 0.5);
	sigma ~ exponential(1);
	Rho ~ lkj_corr(2);

	// Multivariate normal
  {
	  vector[2] YY[N_district];
	  vector[2] MU;
	  MU = [alpha_bar, beta_bar]';
	  for (j in 1:N_district) {
	  	YY[j] = [alpha[j], beta[j]]';
	  }
	  YY ~ multi_normal(MU, quad_form_diag(Rho, sigma));
  }

  // Beta scale_age prior
	beta_scale_age ~ normal(0, 1.5);
	beta_children ~ normal(0, 1.5);

	// For each for in data, alpha and beta for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]] + beta[district[i]] * urban[i] + beta_scale_age * scale_age[i] + beta_children * n_children[i]);
  }

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}
```
```{r, cache = TRUE}
# model_q2_b_stan <- 'model_q2_b.stan'
# writeLines(readLines(model_q2_b_stan))
# model_q2_b <- cmdstan_model(model_q2_b_stan, cpp_options = list(stan_threads = TRUE))

model_q2_b_sample <-
	model_q2_b$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4,
		refresh = 0
	)

model_q2_b_draws <- cmd_draws(model_q2_b_sample)
setDT(model_q2_b_draws)
```


```{r}
precis(model_q2_a_draws[, .SD, .SDcols = patterns('beta')])
precis(model_q2_b_draws[, .SD, .SDcols = patterns('beta')])
```

## Question 3

> Modify any models from Problem 2 that contained that children variable and
model the variable now as a monotonic ordered category, like education from the
week we did ordered categories. Education in that example had 8 categories.
Children here will have fewer (no one in the sample had 8 children). So modify
the code appropriately. What do you conclude about the causal influence of each
additional child on use of contraception?


```{r}
K <- DT[, max(living.children)] - 1
model_data <- c(
	as.list(DT[, .(contraception, district, urban, scale_age,
								 n_children = living.children)]),
	N = DT[, .N], 
	K = K,
	N_district = DT[, uniqueN(district)],
	alpha_k = list(rep(2L, K))
)

```

```{cmdstan, output.var = 'model_q3', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // K categories
  int K;
  vector[K] alpha_k;

  // District, contraception and urban, expecting integers of length N
	int district[N];
	int contraception[N];
	int urban[N];

	// Also scale_age, n_children
	real scale_age[N];
	int n_children[N];
}
parameters {
	// Alpha and beta urban vectors matching length of number of districts
	vector[N_district] alpha;

	// Beta urban vector matching length of number of districts
	vector[N_district] beta;

	// Hyper parameter alpha bar, beta bar
	real alpha_bar;
	real beta_bar;

	// scale_age and n_children
	real beta_scale_age;
	real beta_children;

	// Correlation matrix, sigma
	// 2 represents the number of predictors
	corr_matrix[2] Rho;
	vector<lower=0>[2] sigma;

	simplex[3] delta;
}
model {
	// p vector matching length of number of districts
  vector[N] p;

  // Hyper priors: alpha bar, beta urban bar, sigma and Rho
	alpha_bar ~ normal(0, 1);
	beta_bar ~ normal(0, 0.5);
	sigma ~ exponential(1);
	Rho ~ lkj_corr(2);

	//
	vector[K] delta_shell;
	delta ~ dirichlet(alpha_k);
	delta_shell = append_row(0, delta);

	// Multivariate normal
  {
	  vector[2] YY[N_district];
	  vector[2] MU;
	  MU = [alpha_bar, beta_bar]';
	  for (j in 1:N_district) {
	  	YY[j] = [alpha[j], beta[j]]';
	  }
	  YY ~ multi_normal(MU, quad_form_diag(Rho, sigma));
  }

  // Beta scale_age prior
	beta_scale_age ~ normal(0, 1.5);
	beta_children ~ normal(0, 1.5);

	// For each for in data, alpha and beta for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]] + beta[district[i]] * urban[i] + beta_scale_age * scale_age[i] + beta_children * sum(delta_shell[1:n_children[i]]) * n_children[i]);
  }

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}
```

```{r, cache = TRUE}
# model_q3_stan <- 'model_q3.stan'
# writeLines(readLines(model_q3_stan))
# model_q3 <- cmdstan_model(model_q3_stan, cpp_options = list(stan_threads = TRUE))

model_q3_sample <-
	model_q3$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4,
		refresh = 0
	)

model_q3_draws <- cmd_draws(model_q3_sample)
setDT(model_q3_draws)

precis(model_q3_draws[, .SD, .SDcols = patterns('beta')])
precis(model_q3_draws[, .SD, .SDcols = patterns('delta')], 3)

mcmc_areas(model_q3_draws, regex_pars = 'delta')
```
