---
author: "Alec L. Robitaille"
output: github_document
editor_options: 
  chunk_output_type: console
---

# Homework: Week 9
2021-09-14 [updated: `r Sys.Date()`]

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rethinking)
options(digits = 2, scipen = 999)
```

### Setup

```{r}
# Packages
library(ggdag)
library(dagitty)
library(data.table)
library(ggplot2)
library(rethinking)
library(cmdstanr)
library(posterior)
library(bayesplot)
library(boot)
library(loo)

# Functions
dag_plot <- function(dag) {
	stat <- node_status(dag, FALSE)
	stat$data$status[is.na(stat$data$status)] <- 'intermediate'
	ggplot(stat, aes(x = x, y = y, xend = xend, yend = yend)) +
	  geom_dag_point(aes(color = status), alpha = 0.5, size = 15) +
	  geom_dag_edges() +
		labs(color = '') + 
	  geom_dag_text(color = 'black') +
		scale_color_manual(values = list('exposure' = '#35608DFF',
																		 'outcome' = '#22A884FF',
																		 'intermediate' = 'grey50')) + 
	  theme_void()
}

cmd_draws <- function(model) {
	as_draws_df(model$draws())
}
```


## Question 1

> Revisit the Bangladesh fertility data, data(bangladesh). Fit a model with both
varying intercepts by district_id and varying slopes of urban (as a 0/1
indicator variable) by district_id. You are still predicting use.contraception.
Inspect the correlation between the intercepts and slopes. Can you interpret
this correlation, in terms of what it tells you about the pattern of
contraceptive use in the sample? It might help to plot the varying effect
estimates for both the intercepts and slopes, by district. Then you can
visualize the correlation and maybe more easily think through what it means to
have a particular correlation. Plotting predicted proportion of women using
contraception, in each district, with urban women on one axis and rural on the
other, might also help.

```{r}
data(bangladesh)
DT <- data.table(bangladesh)
precis(DT)

DT[, id := as.integer(woman)]
DT[, district := as.integer(as.factor(district))]
DT[, contraception := use.contraception]

model_data <- c(as.list(DT[, .(contraception, district, urban)]), 
								N = DT[, .N], N_district = DT[, uniqueN(district)])
```


```{r}
register_knitr_engine(override = FALSE)
```

```{cmdstan, output.var = 'model_q1', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // District, contraception and urban, expecting integers of length N
	int district[N];
	int contraception[N];
	int urban[N];
}
parameters {
	// Alpha and beta urban vectors matching length of number of districts
	vector[N_district] alpha;

	// Beta urban vector matching length of number of districts
	vector[N_district] beta;

	// Hyper parameter alpha bar, beta bar
	real alpha_bar;
	real beta_bar;

	// Correlation matrix, sigma
	// 2 represents the number of predictors
	corr_matrix[2] Rho;
	vector<lower=0>[2] sigma;
}
model {
	// p vector matching length of number of districts
  vector[N] p;

  // Hyper priors: alpha bar, beta urban bar, sigma and Rho
	alpha_bar ~ normal(0, 1);
	beta_bar ~ normal(0, 0.5);
	sigma ~ exponential(1);
	Rho ~ lkj_corr(2);

	// Multivariate normal
  {
	  vector[2] YY[N_district];
	  vector[2] MU;
	  MU = [alpha_bar, beta_bar]';
	  for (j in 1:N_district) {
	  	YY[j] = [alpha[j], beta[j]]';
	  }
	  YY ~ multi_normal(MU, quad_form_diag(Rho, sigma));
  }

	// For each for in data, alpha and beta for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]] + beta[district[i]] * urban[i]);
  }

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}
```

<!-- https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-hierarchical-priors-section.html#optimization-through-vectorization -->


```{r, cache = TRUE}
# model_q1_stan <- 'model_q1.stan'
# writeLines(readLines(model_q1_stan))
# model_q1 <- cmdstan_model(model_q1_stan, cpp_options = list(stan_threads = TRUE))

model_q1_sample <-
	model_q1$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model_q1_draws <- cmd_draws(model_q1_sample)

mcmc_areas(model_q1_draws, regex_pars = 'alpha')
mcmc_areas(model_q1_draws, regex_pars = 'beta')
mcmc_areas(model_q1_draws, regex_pars = 'bar')
mcmc_areas(model_q1_draws, regex_pars = 'Rho')

precis(model_q1_draws[, .SD, .SDcols = patterns('*bar')])
precis(model_q1_draws[, .SD, .SDcols = patterns('Rho|sigma')], depth = 3)

mcmc_hex(model_q1_draws, regex_pars = '*bar')
```



