---
author: "Alec L. Robitaille"
output: github_document
editor_options: 
  chunk_output_type: console
---

# Homework: Week 8
2021-09-08 [updated: `r Sys.Date()`]

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rethinking)
options(digits = 2, scipen = 999)
```

### Setup

```{r}
# Packages
library(ggdag)
library(dagitty)
library(data.table)
library(ggplot2)
library(rethinking)
library(cmdstanr)
library(posterior)
library(bayesplot)
library(boot)

# Functions
dag_plot <- function(dag) {
	stat <- node_status(dag, FALSE)
	stat$data$status[is.na(stat$data$status)] <- 'intermediate'
	ggplot(stat, aes(x = x, y = y, xend = xend, yend = yend)) +
	  geom_dag_point(aes(color = status), alpha = 0.5, size = 15) +
	  geom_dag_edges() +
		labs(color = '') + 
	  geom_dag_text(color = 'black') +
		scale_color_manual(values = list('exposure' = '#35608DFF',
																		 'outcome' = '#22A884FF',
																		 'intermediate' = 'grey50')) + 
	  theme_void()
}

cmd_draws <- function(model) {
	as_draws_df(model$draws())
}
```


## Question 1


### Data
```{r}
data(reedfrogs)
DT <- data.table(reedfrogs)
precis(DT)
```


```{r}
register_knitr_engine(override = FALSE)
```

```{cmdstan, output.var = 'model_frogs_1', cache = TRUE}
data {
	int N;
	int survival[N];
	int density[N];
	int tank[N];
}
parameters {
	real sigma;
	real alpha[N];
	real alpha_bar;
}
transformed parameters {
	vector[N] p;

	for (i in 1:N) {
		p[i] = inv_logit(alpha[i]);
	}
}
model {
	alpha ~ normal(alpha_bar, sigma);
	sigma ~ exponential(1);
	for (i in 1:N) {
		survival[i] ~ binomial(density[i], p[i]);
	}
}

```

```{r, cache = TRUE}
# model_frogs_1_stan <- 'model_frogs_1.stan'
# writeLines(readLines(model_frogs_1_stan))
# model_frogs_1 <- cmdstan_model(model_frogs_1_stan, cpp_options = list(stan_threads = TRUE))

model_data <- c(
	as.list(DT[, .(
		survival = surv,
		density,
		predation = as.integer(pred),
		size = as.integer(size),
		tank = seq.int(.N)
	)]), 
	N = DT[, .N]
)

model_frogs_1_sample <-
	model_frogs_1$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)

model_frogs_1_draws <- cmd_draws(model_frogs_1_sample)

mcmc_areas(model_frogs_1_draws, regex_pars = 'alpha')
mcmc_areas(model_frogs_1_draws, regex_pars = 'p\\[')
```


```{cmdstan, output.var = 'model_frogs_2', cache = TRUE}
data {
	int N;
	int survival[N];
	int density[N];
	int tank[N];
	int predation[N];
}
parameters {
	real sigma;
	real alpha[N];
	real alpha_bar;
	real beta_predation;
}
transformed parameters {
	vector[N] p;

	for (i in 1:N) {
		p[i] = inv_logit(alpha[i] + beta_predation * predation[i]);
	}
}
model {
	alpha ~ normal(alpha_bar, sigma);
	beta_predation ~ normal(0, 0.5);
	sigma ~ exponential(1);
	for (i in 1:N) {
		survival[i] ~ binomial(density[i], p[i]);
	}
}
```

```{r, cache = TRUE}
# model_frogs_2_stan <- 'model_frogs_2.stan'
# writeLines(readLines(model_frogs_2_stan))
# model_frogs_2 <- cmdstan_model(model_frogs_2_stan, cpp_options = list(stan_threads = TRUE))

model_frogs_2_sample <-
	model_frogs_2$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)
model_frogs_2_draws <- cmd_draws(model_frogs_2_sample)
mcmc_areas(model_frogs_2_draws, regex_pars = 'predation')
```

```{cmdstan, output.var = 'model_frogs_3', cache = TRUE}
data {
	int N;
	int survival[N];
	int density[N];
	int tank[N];
	int size[N];
}
parameters {
	real sigma;
	real alpha[N];
	real alpha_bar;
	real beta_size;
}
transformed parameters {
	vector[N] p;

	for (i in 1:N) {
		p[i] = inv_logit(alpha[i] + beta_size * size[i]);
	}
}
model {
	alpha ~ normal(alpha_bar, sigma);
	beta_size ~ normal(0, 0.5);
	sigma ~ exponential(1);
	for (i in 1:N) {
		survival[i] ~ binomial(density[i], p[i]);
	}
}
```

```{r, cache = TRUE}
# model_frogs_3_stan <- 'model_frogs_3.stan'
# writeLines(readLines(model_frogs_3_stan))
# model_frogs_3 <- cmdstan_model(model_frogs_3_stan, cpp_options = list(stan_threads = TRUE))

model_frogs_3_sample <-
	model_frogs_3$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)
model_frogs_3_draws <- cmd_draws(model_frogs_3_sample)
mcmc_areas(model_frogs_3_draws, regex_pars = 'size')
```

```{cmdstan, output.var = 'model_frogs_4', cache = TRUE}
data {
	int N;
	int survival[N];
	int density[N];
	int tank[N];
	int size[N];
	int predation[N];
}
parameters {
	real sigma;
	real alpha[N];
	real alpha_bar;
	real beta_size;
	real beta_predation;
	real beta_interaction;
}
transformed parameters {
	vector[N] p;

	for (i in 1:N) {
		p[i] = inv_logit(alpha[i] + beta_size * size[i] + beta_predation * predation[i] + beta_interaction * (size[i] * predation[i]));
	}
}
model {
	alpha ~ normal(alpha_bar, sigma);
	beta_size ~ normal(0, 0.5);
	beta_predation ~ normal(0, 0.5);
	beta_interaction ~ normal(0, 0.25);
	sigma ~ exponential(1);
	for (i in 1:N) {
		survival[i] ~ binomial(density[i], p[i]);
	}
}
```

```{r, cache = TRUE}
# model_frogs_4_stan <- 'model_frogs_4.stan'
# writeLines(readLines(model_frogs_4_stan))
# model_frogs_4 <- cmdstan_model(model_frogs_4_stan, cpp_options = list(stan_threads = TRUE))

model_frogs_4_sample <-
	model_frogs_4$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)
model_frogs_4_draws <- cmd_draws(model_frogs_4_sample)
mcmc_areas(model_frogs_4_draws, regex_pars = 'beta')
```

Negative influence of predation is somewhat balanced by size of tank. 


<!-- TODO use AIC -->


## Question 2

> In 1980, a typical Bengali woman could have 5 or more children in her
lifetime. By the year 2000, a typical Bengali woman had only 2 or 3. Youâ€™re
going to look at a historical set of data, when contraception was widely
available but many families chose not to use it. These data reside in
`data(bangladesh)` and come from the 1988 Bangladesh Fertility Survey. Each row
is one of 1934 women. There are six variables, but you can focus on two of them
for this practice problem: (1) district: ID number of administrative district
each woman resided in (2) use.contraception: An indicator (0/1) of whether the
woman was using contraception. 

```{r}
data(bangladesh)
DT <- data.table(bangladesh)
precis(DT)

DT[, id := as.integer(woman)]
DT[, district := as.integer(as.factor(district))]
DT[, contraception := use.contraception]

model_data <- c(as.list(DT[, .(contraception, district)]), 
								N = DT[, .N], N_district = DT[, uniqueN(district)])
```

Now, focus on predicting `use.contraception`, clustered by `district_id`. Fit
both (1) a traditional fixed-effects model that uses an index variable for
district and (2) a multilevel model with varying intercepts for district. Plot
the predicted proportions of women in each district using contraception, for
both the fixed-effects model and the varying-effects model. That is, make a plot
in which district ID is on the horizontal axis and expected proportion using
contraception is on the vertical.Make one plot for each model, or layer them on
the same plot, as you prefer. How do the models disagree? Can you explain the
pattern of disagreement? In particular, can you explain the most extreme cases
of disagreement, both why they happen where they do and why the models reach
different inferences?


Fixed effects model

```{cmdstan, output.var = 'model_bang_fixed', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // District and contraception, expecting integers of length N
	int district[N];
	int contraception[N];
}
parameters {
	// Alpha vector matching length of number of districts
	vector[N_district] alpha;
}
model {
	// p vector matching length of number of districts
  vector[N] p;

  // Alpha is distributed normally
	alpha ~ normal(0, 1.5);

	// For each for in data, alpha for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]]);
  }

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}
```

```{r, cache = TRUE}
# model_bang_fixed_stan <- 'model_bang_fixed.stan'
# writeLines(readLines(model_bang_fixed_stan))
# model_bang_fixed <- cmdstan_model(model_bang_fixed_stan, cpp_options = list(stan_threads = TRUE))

model_bang_fixed_sample <-
	model_bang_fixed$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)
model_bang_fixed_draws <- cmd_draws(model_bang_fixed_sample)
mcmc_areas(model_bang_fixed_draws, regex_pars = 'alpha', transformations = inv.logit)
```

Multilevel  model

```{cmdstan, output.var = 'model_bang_multi', cache = TRUE}
data {
	// Integers for number of rows, and number of districts
  int<lower=0> N;
  int<lower=0> N_district;

  // District and contraception, expecting integers of length N
	int district[N];
	int contraception[N];
}
parameters {
	// Alpha vector matching length of number of districts
	vector[N_district] alpha;
	real<lower=0> sigma;

	// Hyper parameter alpha bar
	real alpha_bar;
}
transformed parameters {
	// p vector matching length of number of districts
  vector[N] p;

	// For each for in data, alpha for that row's district
  for (i in 1:N) {
  	p[i] = inv_logit(alpha[district[i]]);
  }
}
model {
  // Hyper priors: alpha bar and sigma
	alpha_bar ~ normal(0, 1.5);
	sigma ~ exponential(1);

	// Priors
  // Alpha is distributed normally
  alpha ~ normal(alpha_bar, sigma);

  // Contraception if distributed with bernoulli, p
  contraception ~ bernoulli(p);
}
```

```{r, cache = TRUE}
# model_bang_multi_stan <- 'model_bang_multi.stan'
# writeLines(readLines(model_bang_multi_stan))
# model_bang_multi <- cmdstan_model(model_bang_multi_stan, cpp_options = list(stan_threads = TRUE))

model_bang_multi_sample <-
	model_bang_multi$sample(
		data = model_data,
		chains = 4,
		parallel_chains = 4,
		threads_per_chain = 4
	)
model_bang_multi_draws <- cmd_draws(model_bang_multi_sample)

mcmc_trace(model_bang_multi_draws)
mcmc_areas(model_bang_multi_draws, regex_pars = 'alpha', transformations = inv.logit)
mcmc_areas(model_bang_multi_draws, pars = c('alpha_bar', 'sigma'))
```


Comparison

```{r}
(mcmc_areas(model_bang_fixed_draws, regex_pars = 'alpha', transformations = inv.logit) + labs(title = 'fixed')) + 
	(mcmc_areas(model_bang_multi_draws, regex_pars = 'alpha\\[', transformations = inv.logit) + labs(title = 'multilevel'))

setDT(model_bang_fixed_draws)
setDT(model_bang_multi_draws)

compare <- rbindlist(list(
	melt(model_bang_fixed_draws, measure.vars = patterns('alpha'))[, model_type := 'fixed'],
	melt(model_bang_multi_draws, measure.vars = patterns('alpha'))[, model_type := 'multilevel']
), fill = TRUE)

compare[, variable := as.integer(gsub('alpha\\[|\\]', '', variable))]
ggplot(compare[, .(value = mean(value)), .(variable, model_type)]) + 
	geom_hline(yintercept = 0, alpha = 0.5) + 
	geom_point(aes(variable, value, color = model_type)) +
	geom_line(aes(variable, value, group = model_type), alpha = 0.2) +
	scale_color_viridis_d(begin = 0.3, end = 0.8) + 
	labs(x = 'district', y = 'alpha')
```


```{r}
library(rethinking)
data(bangladesh)
d <- bangladesh
d$district_id <- as.integer(as.factor(d$district))
dat_list <- list(
C = d$use.contraception,
did = d$district_id
)
m2.2 <- ulam(
alist(
C ~ bernoulli( p ),
logit(p) <- a[did],
a[did] ~ normal( a_bar , sigma ),
a_bar ~ normal( 0 , 1.5 ),
sigma ~ exponential( 1 )
) , data=dat_list , chains=4 , cores=4 , log_lik=TRUE )

```


## Question 3

> Return to the Trolley data, `data(Trolley)`, from Chapter 12. Define and fit a
varying intercepts model for these data. By this I mean to add an intercept
parameter for the individual to the linear model. Cluster the varying intercepts
on individual participants, as indicated by the unique values in the id
variable. Include action, intention, and contact as before. Compare the varying
intercepts model and a model that ignores individuals, using both WAIC/LOO and
posterior predictions. What is the impact of individual variation in these data?

